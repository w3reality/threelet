<!DOCTYPE html>
<html>
<head>
    <meta http-equiv="Content-type" content="text/html; charset=utf-8"/>
    <title>rust-canvas-hello</title>
</head>
<body>
    <div> <!-- threelet ======== -->
        <canvas id="demo" style="width: 100%; height: 100%;"></canvas>
    </div>

    <div> <!-- canvas bindgen example ======== -->
        <!-- <canvas id="canvas" height="256" width="256"></canvas> -->
    </div>

    <script src="../deps/three.min.js"></script>
    <script src="../deps/OrbitControls.js"></script>
    <script src="../deps/WebVR.js"></script>
    <script src="../deps/Sky.js"></script>
    <script src="../../dist/threelet.min.js"></script>

    <script type="module">
    // import Threelet from '../../src/index.js'; // dev only

    // TODO !!!! maybe refactor into examples/templates/plane-app.js
    class PlaneApp extends Threelet {
        // override
        onCreate(params) {
            const controls = this.setup('mod-controls', THREE.OrbitControls);
            controls.enableRotate = false;
            // controls.enablePan = false;

            // this.setup('mod-stats', window.Stats, {panelType: 0}); // 0: fps, 1: ms, 2: mb, 3+: custom
            this.setup('mod-webvr', window.WEBVR);
            this.setup('mod-sky', THREE.Sky);

            const _planeCanvas = PlaneApp.createPlaneCanvas(params.planeCanvasId);
            this.planeCtx = _planeCanvas.getContext('2d');
            this.selector = PlaneApp.createSelector(_planeCanvas);
            this.plane = this.selector.getObjectByName('plane');
            this.drawTitle(this.planeCtx);
            this.drawCommands(this.planeCtx);

            this.selector.add(PlaneApp.createMarker('commandMarker'));

            const group = this.getInteractiveGroup();
            group.add(this.selector); // for ray not passing ghrough the selector surface
            this.scene.add(group);

            this.scene.add(Threelet.Utils.createTestHemisphereLight());
            this.scene.add(Threelet.Utils.createTestDirectionalLight());
            this.scene.add(new THREE.GridHelper(10, 20));

            const inputCallbacks = {
                onClick: (mx, my) => {
                    const isec = this.mouseToPlaneIntersect(mx, my);
                    // console.log('@@ onClick(): isec:', isec);
                    if (isec && PlaneApp.isPointOnLeftSquare(isec.point)) {
                        // console.log('@@ isec.faceIndex:', isec.faceIndex);
                        this.onLeftPlaneClicked(isec.faceIndex);
                    }
                },
            };

            if (1) {
                if (Threelet.isVrSupported()) { // Oculus Go, desktop-firefox
                    // KLUDGE - when in desktop mode, Oculus browser triggers
                    //   both mouse/touch events at a time.
                    //   also, mouse-drag events seems not being fired...
                    //   So, enabling only pointer events here
                    //   (touch events NG for desktop-firefox).
                    this.setupPointerInterface(inputCallbacks);
                } else { // desktop-chrome, desktop-safari
                    this.setupMouseInterface(inputCallbacks);
                    this.setupTouchInterface(inputCallbacks);
                }
            } else { // requires iOS >= 13
                this.setupPointerInterface(inputCallbacks);
            }


            this._vrPressPlaneStart = [-1, -1]; // faceIndex per controller i
            this.on('vr-trigger-press-start', (i) => {
                const isec = this.vrcontrollerToPlaneIntersect(i);
                if (isec) {
                    console.log('@@ vr-press-start');
                    this._vrPressPlaneStart[i] = isec.faceIndex;
                    // this.invokeSigPadCall('_strokeBegin', isec.point.x, isec.point.y);
                } else {
                    this._vrPressPlaneStart[i] = -1;
                }
            });
            this.on('vr-trigger-press-end', (i) => {
                // this.invokeSigPadCall('_strokeEnd', -1, -1);
                if (this._vrPressPlaneStart[i] < 0) return;

                const lastFaceIndex = this._vrPressPlaneStart[i];
                this._vrPressPlaneStart[i] = -1;

                // check vr-click
                const isec = this.vrcontrollerToPlaneIntersect(i);
                if (isec) {
                    const faceIndex = isec.faceIndex;
                    console.log('@@ vr-press-end; faceIndex:', faceIndex);
                    if (Math.floor(faceIndex/2) ===
                        Math.floor(lastFaceIndex/2)) {
                        console.log('@@ vr-click fulfilled for faceIndex:', faceIndex);
                        if (isec && PlaneApp.isPointOnLeftSquare(isec.point)) {
                            this.onLeftPlaneClicked(isec.faceIndex);
                        }
                    }
                }
            });

            this.scene.add(this.getInteractiveGroup());

            this.cube = Threelet.Utils.createTestCube([0.4, 0.1, 0.4], 0xff00ff);
            this.scene.add(this.cube);
        } // end onCreate()

        // override
        onUpdate(t, dt) {
            this.cube.position.set(Math.cos(t), 0.5, Math.sin(t));
            this.cube.rotation.z += dt;

            if (1) { // TODO only when bindgen/clear new draw !!!!!!!!!!!!!!
                this.plane.material.map.needsUpdate = true;
            }
        }

        // px, py:
        // -2,2    0,2    2,2
        //     left   right
        // -2,0    0,0    2,0
        static isPointOnLeftSquare(pt) {
            return pt.x < 0 && pt.x > -2 && pt.y > 0 && pt.y < 2;
        }
        static isPointOnRightSquare(pt) {
            return pt.x > 0 && pt.x < 2 && pt.y > 0 && pt.y < 2;
        }
        mouseToPlaneIntersect(mx, my) {
            const isec = this.raycastFromMouse(mx, my, [this.plane], false);
            return isec ? isec : null;
        }
        vrcontrollerToPlaneIntersect(i) {
            return this.raycastFromController(i, [this.plane], false)[0];
        };

        static createMarker(name) {
            const markerCanvas = document.createElement('canvas');
            markerCanvas.width = 64;
            markerCanvas.height = 32;
            const ctx = markerCanvas.getContext('2d');
            ctx.fillStyle = '#000';
            ctx.fillRect(0, -6+32, markerCanvas.width, 2);
            ctx.fillStyle = '#fff';
            ctx.fillRect(0, -4+32, markerCanvas.width, 2);
            ctx.fillStyle = '#000';
            ctx.fillRect(0, -2+32, markerCanvas.width, 2);
            const marker = Threelet.Utils.createCanvasPlane(markerCanvas, 0.5, 0.25);
            marker.material.map.magFilter = THREE.NearestFilter;
            marker.material.map.minFilter = THREE.NearestFilter;
            marker.material.transparent = true;
            marker.material.opacity = 0.5;
            marker.name = name;
            marker.visible = false;
            return marker;
        }
        static createSelector(planeCanvas) {
            const selector = new THREE.Group();
            Threelet.hasVrDisplay(tf => selector.position.set(0, 1, tf ? -3.5 : -0.5));

            const plane = Threelet.Utils.createCanvasPlane(planeCanvas, 4, 2, 8, 8);
            if (0) { // control tex opacity
                plane.material.transparent = true;
                plane.material.opacity = 0.9;
            }
            if (1) { // control tex sharpness
                plane.material.map.magFilter = THREE.NearestFilter;
                plane.material.map.minFilter = THREE.NearestFilter;
            }

            plane.name = 'plane';
            selector.add(plane);

            return selector;
        }

        drawInfo(lines) {
            const ctx = this.planeCtx;
            ctx.fillStyle = '#cccccc';
            ctx.font = '13px monospace';

            let offset = 3;
            for (let line of lines) {
                ctx.fillText(line, 8, (offset++)*32+20);
            }
        }
        clearPaintArea(ctx) {
            PlaneApp._clearPaintArea(this.planeCtx);
        }
        static _clearPaintArea(ctx) {
            // ctx.fillStyle = '#000';
            // ctx.fillRect(256, 0, 256, 256);
            // ctx.fillStyle = '#fff';
            // ctx.fillRect(256+16, 16, 224, 224);
            //----
            // const clearColor = '#fff';
            const clearColor = `#${Math.floor(Math.random()*9)}${Math.floor(Math.random()*9)}${Math.floor(Math.random()*9)}`;
            console.log('clearColor:', clearColor);
            ctx.fillStyle = clearColor;
            ctx.fillRect(256, 0, 256, 256);
        }

        static createPlaneCanvas(id) {
            const planeCanvas = document.createElement('canvas');
            planeCanvas.width = 512;
            planeCanvas.height = 256;
            if (0) { // only for canvas bindgen example
                planeCanvas.id = id;
                document.body.appendChild(planeCanvas);
            }

            const planeCtx = planeCanvas.getContext('2d');
            planeCtx.fillStyle = '#222';
            planeCtx.fillRect(0, 0, 256, 256);
            PlaneApp._clearPaintArea(planeCtx);

            // PlaneApp.drawTitle(planeCtx);
            // this.drawTitle();
            // PlaneApp.drawSelectionCommands(planeCtx);
            return planeCanvas;
        }

        getMarker(name) {
            return this.selector.getObjectByName(name);
        }

        // abstract
        drawTitle(ctx) {
            throw 'drawTitle() not implemented';
        }

        // abstract
        drawCommands(ctx) {
            throw 'drawCommands() not implemented';
        }

        // abstract
        onLeftPlaneClicked(faceIndex) {
            throw 'onLeftPlaneClicked() not implemented';
        }
    }

    class Demo extends PlaneApp {
        // override
        onCreate(params) {
            super.onCreate(params);

            // Threelet.Utils.createCanvasFromImage('./control.png', can => {
            //     // console.log('@@ can:', can);
            //     // document.body.appendChild(can); // debug
            //     this.illustrationCanvas = can;
            // });

            this.reIni = -0.15;
            this.imIni = 0.65;
            this.jsetData = {
                mod: null,
                re: this.reIni,
                im: this.imIni,
            };
            (async () => {
                const mod = await Threelet.Utils.loadWasmBindgen(
                    './julia_set', await import(`./julia_set.export.js`));
                console.log('juliaset mod:', mod);
                this.jsetData.mod = mod;
                this.updateJset();
            })();
        }

        updateJset() {
            const data = this.jsetData;
            console.log('@@ data:', data);
            this.updateC(data.re, data.im);

            if (! data.mod) return;
            if (! this.planeCtx) return;
            data.mod.draw(this.planeCtx, 256, 256, 0.005*2.4, data.re, data.im);
        }

        updateC(re, im) {
            // TODO!!!!!!!!
        }

        // updateIllustration(tf) {
        //     const ctx = this.planeCtx;
        //     if (tf && this.illustrationCanvas) {
        //         // draw a 128 x 256 image
        //         ctx.drawImage(this.illustrationCanvas, 0, 128);
        //     } else { // 'hide' the illustration
        //         ctx.fillStyle = '#000000';
        //         ctx.fillRect(0, 128, 256, 128);
        //     }
        // }

        // impl
        drawTitle(ctx) {
            ctx.fillStyle = '#cccccc';
            ctx.font = '18px monospace';
            ctx.fillText('ðŸ¦€rust-canvas-juliaset', 16, 32+8);
        }

        // impl
        drawCommands(ctx) {
            // TODO fancy refactored method to skip this brute hardcoding...
            //-------- 2nd row
            ctx.fillStyle = '#444444';
            // ctx.fillRect(0*64, 2*32, 64, 32);
            // ctx.fillRect(1*64, 2*32, 64, 32);
            // ctx.fillRect(2*64, 2*32, 64, 32);
            // ctx.fillRect(3*64, 2*32, 64, 32);
            ctx.fillStyle = '#cccccc'; //---- bg
            ctx.font = '13px monospace';
            ctx.fillText('Draw Julia set with', 0*64+8, 2*32+20);
            // ctx.fillText('', 1*64+8, 2*32+20);
            // ctx.fillText('', 2*64+8, 2*32+20);
            // ctx.fillText('', 3*64+8, 2*32+20);
            //-------- 3rd row
            ctx.fillStyle = '#444444';
            //ctx.fillRect(0*64, 3*32, 64, 32);
            //ctx.fillRect(1*64, 3*32, 64, 32);
            ctx.fillRect(2*64, 3*32, 64, 32);
            ctx.fillRect(3*64, 3*32, 64, 32);
            ctx.fillStyle = '#cccccc'; //---- bg
            ctx.font = '13px monospace';
            ctx.fillText('Re(C): -0.15', 0*64+8, 3*32+20);
            // ctx.fillText('', 1*64+8, 3*32+20);
            ctx.fillText('  -', 2*64+8, 3*32+20);
            ctx.fillText('  +', 3*64+8, 3*32+20);
            //-------- 4th row
            ctx.fillStyle = '#444444';
            //ctx.fillRect(0*64, 4*32, 64, 32);
            //ctx.fillRect(1*64, 4*32, 64, 32);
            ctx.fillRect(2*64, 4*32, 64, 32);
            ctx.fillRect(3*64, 4*32, 64, 32);
            ctx.fillStyle = '#cccccc'; //---- bg
            ctx.font = '13px monospace';
            ctx.fillText('Im(C): 0.65', 0*64+8, 4*32+20);
            // ctx.fillText('', 1*64+8, 4*32+20);
            ctx.fillText('  -', 2*64+8, 4*32+20);
            ctx.fillText('  +', 3*64+8, 4*32+20);
            //-------- 5th row
            ctx.fillStyle = '#444444';
            // ctx.fillRect(0*64, 5*32, 64, 32);
            ctx.fillRect(1*64, 5*32, 64, 32);
            // ctx.fillRect(2*64, 5*32, 64, 32);
            // ctx.fillRect(3*64, 5*32, 64, 32);
            ctx.fillStyle = '#cccccc'; //---- bg
            ctx.font = '13px monospace';
            // ctx.fillText('', 0*64+8, 5*32+20);
            ctx.fillText('Reset', 1*64+8, 5*32+20);
            // ctx.fillText('', 2*64+8, 5*32+20);
            // ctx.fillText('', 3*64+8, 5*32+20);
            //-------- 7th row
            ctx.fillStyle = '#444444';
            ctx.fillRect(0*64, 7*32, 64, 32);
            ctx.fillRect(1*64, 7*32, 64, 32);
            ctx.fillStyle = '#cccccc'; //---- bg
            ctx.fillText('source code', 0*64+8, 7*32+20);
        }

        updateMarker(what, row, col, width=1) {
            const marker = this.getMarker(
                what.startsWith('cmd-') ? 'commandMarker' : 'invalid');
            if (! marker) return;

            // note: position is relative to the 'selector' group
            marker.position.set(-2+0.25*col, 0.125+0.25*(3-row), 0.005);
            marker.scale.set(width, 1, 1);
            marker.visible = true;

            if (what.startsWith('cmd-')) {
                setTimeout(() => { marker.visible = false; }, 500);
            }
            this.render();
        }

        // impl
        onLeftPlaneClicked(faceIndex) {
            console.log('faceIndex:', faceIndex);
            const _fn = (what, row, col, width) => {
                this.onSelect(what);
                this.updateMarker(what, row, col, width);
            };
            switch (faceIndex) {
                case 52: case 53: _fn('cmd-resub', 3, 5, 1); break;
                case 54: case 55: _fn('cmd-readd', 3, 7, 1); break;
                case 68: case 69: _fn('cmd-imsub', 4, 5, 1); break;
                case 70: case 71: _fn('cmd-imadd', 4, 7, 1); break;
                case 82: case 83: _fn('cmd-reset', 5, 3, 1); break;
                case 112: case 113: case 114: case 115: _fn('cmd-src', 7, 2, 2); break;
                default: console.log('@@ nop');
            }
        }

        onSelect(what) {
            if (what.startsWith('cmd-')) {
                const command = what.replace('cmd-', '');
                switch (command) {
                    case 'resub': {
                        console.log('re-');
                        this.jsetData.re -= 0.01;
                        this.updateJset();
                        break;
                    }
                    case 'readd': {
                        console.log('re+');
                        this.jsetData.re += 0.01;
                        this.updateJset();
                        break;
                    }
                    case 'imsub': {
                        console.log('im-');
                        this.jsetData.im -= 0.01;
                        this.updateJset();
                        break;
                    }
                    case 'imadd': {
                        console.log('im+');
                        this.jsetData.im += 0.01;
                        this.updateJset();
                        break;
                    }
                    case 'reset': {
                        // this.clearPaintArea();
                        this.jsetData.re = this.reIni;
                        this.jsetData.im = this.imIni;
                        this.updateJset();
                        console.log('reset'); break;
                    }
                    case 'src': {
                        // document.location.href = 'https://github.com/w3reality';
                        console.log('src'); break;
                    }
                    default: console.log('@@ unknown command:', command);
                }
            } else {
                console.log('@@ onSelect(): nop');
            }
        }
    }

    const planeCanvasId = 'plane';
    const demo = new Demo({
        canvas: document.getElementById("demo"),
        // optAxes: false,
        planeCanvasId: planeCanvasId,
    });
    // demo.updateLoop(30);
    demo.updateLoop(2); // debug

    (async () => {
        if (0) { // canvas bindgen example
            const mod = await Threelet.Utils.loadWasmBindgen(
                './canvas', await import(`./canvas.export.js`));
            console.log('canvas mod:', mod);

            // mod.draw(planeCanvasId);
            setTimeout(() => { mod.draw(planeCanvasId); }, 2000);
        }
    })();
    </script>
</body>
</html>
